# configuration

rv stores its configuration in `~/.rv/config.toml`. created automatically by `rv init`.

## config file

full example of `~/.rv/config.toml`:

```toml
[connection]
host = "rivanna"
user = "abc1de"
hostname = "rivanna.hpc.virginia.edu"

[defaults]
account = "mygroup"
gpu_type = "a6000"
time = "2:59:00"
partition = "gpu-a6000"
ai_naming = true
ai_api_key = "sk-..."

[paths]
scratch = "/scratch/abc1de"
home = "/home/abc1de"

[notifications]
enabled = true
email = "abc1de@virginia.edu"
token = "..."  # auto-generated by rv init

[scratch_keepalive]
enabled = true  # default: true

[shared]
hf_cache = "/standard/mygroup/.cache/huggingface"  # optional
```

## defaults

default values used when flags are not specified on the command line:

| key       | description                             | example   |
| --------- | --------------------------------------- | --------- |
| account   | Slurm account (allocation group)        | mygroup   |
| gpu_type  | default GPU type when --type is omitted | a6000     |
| time      | default walltime                        | 2:59:00   |
| partition | default Slurm partition                 | gpu-a6000 |

## notifications

rv can email you when jobs complete or fail. notifications are sent to your @virginia.edu address via HMAC-signed webhooks.

enable during `rv init` or set manually in config.toml:

```toml
[notifications]
enabled = true
email = "abc1de@virginia.edu"
```

notification events: COMPLETED, FAILED, TIMEOUT, RESUBMITTED (checkpoint-restart).

## ai naming

rv can auto-generate descriptive job names using an AI model. set your API key in config.toml — rv auto-detects the provider from the key prefix:

| key prefix | provider  |
| ---------- | --------- |
| sk-ant-    | Anthropic |
| sk-        | OpenAI    |

```toml
[defaults]
ai_naming = true
ai_api_key = "sk-ant-..."
```

## environment variables

use `rv env` to manage variables that are injected into every job. these are stored locally and written to per-job env files at submission time. useful for API keys and other secrets.

env vars are **global** — they apply to all projects and branches. use them for credentials and identity (API keys, tokens). for experiment-specific config, use config files (Hydra, argparse, YAML) which are git-tracked and per-branch by design.

```bash
rv env set HF_TOKEN hf_abc123...
rv env import .env          # bulk-import from a .env file
rv env list
rv env rm HF_TOKEN
```

rv also auto-sets these variables in every job: OMP_NUM_THREADS, TOKENIZERS_PARALLELISM, HF_HOME, VLLM_CACHE_DIR, RV_CHECKPOINT_DIR, RV_OUTPUT_DIR.

## scratch keepalive

Rivanna's scratch filesystem has a 90-day purge policy — files not accessed in 90 days are automatically deleted. this would destroy your venv, environment variables, and caches.

rv automatically prevents this by touching all files under `/scratch/user/.rv/`, `/scratch/user/rv-workspaces/`, and cache directories once per day (on the first rv command of the day). this covers your venv, logs, workspaces, snapshots, and model caches. it runs in the background and adds no latency to your commands.

enabled by default. to disable:

```toml
[scratch_keepalive]
enabled = false
```

## shared storage

if you're part of a lab group with access to persistent group storage (`/standard/` or `/project/`), rv can use it as a shared HuggingFace model cache. this avoids every lab member downloading the same large models to their own scratch.

`rv init` automatically detects group directories via `hdquota` and offers to set this up. if you already have models in `/scratch/user/.cache/huggingface`, rv will offer to migrate them to the shared location. rv also checks the shared filesystem's capacity — if it's over 80% full, you'll see a warning before proceeding.

you can also configure it manually:

```toml
[shared]
hf_cache = "/standard/mygroup/.cache/huggingface"
```

the shared directory is created with group-writable setgid permissions (chmod g+rwxs) so all lab members can read and write models. group storage is persistent — not subject to the 90-day scratch purge. when active, both `~/.cache/huggingface` and `/scratch/user/.cache/huggingface` are symlinked to the shared location.

## paths

rv organizes remote files under your scratch directory:

| path                                                                  | purpose                                  |
| --------------------------------------------------------------------- | ---------------------------------------- |
| /scratch/user/.rv/                                                    | rv home directory                        |
| /scratch/user/.rv/logs/                                               | job output logs                          |
| .../&#123;jobName&#125;-&#123;jobId&#125;.{out,err}                   | single-node log files                    |
| .../&#123;jobName&#125;-&#123;jobId&#125;.node&#123;N&#125;.{out,err} | per-node log files (multi-node jobs)     |
| /scratch/user/.rv/outputs/                                            | persistent job output files              |
| .../&#123;jobName&#125;-&#123;jobId&#125;/                            | per-job output directory (RV_OUTPUT_DIR) |
| /scratch/user/.rv/env/                                                | environment variable files               |
| /scratch/user/.rv/envs/{project}/{branch}/                            | per-project, per-branch Python venv      |
| /scratch/user/rv-workspaces/{project}/{branch}/                       | per-project, per-branch workspace root   |
| .../code/                                                             | mutable workspace (sync target)          |
| .../snapshots/{jobName}-{timestamp}/                                  | per-job immutable snapshot               |
| /scratch/user/.cache/huggingface/                                     | HuggingFace model cache (HF_HOME)        |
| /scratch/user/.cache/uv/                                              | uv package cache                         |

scratch storage is high-performance (Weka filesystem, ~1.5 GB/s write). files are [not backed up](https://www.rc.virginia.edu/userinfo/storage/non-sensitive-data/#scratch) and subject to a 90-day purge policy.

## workspace isolation

rv workspaces are **git-aware**. when you run `rv run` or `rv sync push` from a git repository, rv automatically detects your current branch and organizes remote files by project and branch:

```
/scratch/user/rv-workspaces/myproject/main/code/         ← branch "main"
/scratch/user/rv-workspaces/myproject/feature--foo/code/  ← branch "feature/foo"
```

this means switching branches and running `rv run` won't overwrite code from a different branch.

### snapshots

each `rv run` job gets its own **immutable snapshot** of the code directory. snapshots are created using hardlinks (`cp -al`), making them instant and zero-cost until files change. this prevents a subsequent `rv run` or `rv sync push` from corrupting a running job's files.

snapshots older than 7 days are automatically pruned. (the scratch keepalive protects snapshots from the 90-day Rivanna purge — only rv's own 7-day cleanup applies.)

**important:** your job runs inside the snapshot directory. any files your script writes to relative paths (e.g. `./artifacts/`, `./results/`) land in the snapshot, **not** in your persistent workspace. since snapshots are pruned after 7 days, use one of these approaches:

- write to `RV_OUTPUT_DIR` (set automatically in every job, persists at `/scratch/user/.rv/outputs/{jobName}-{jobId}/`)
- use `--output ./artifacts` on `rv run` to auto-copy paths after completion
- write to an absolute `/scratch/` path manually

```python
import os
output_dir = os.environ.get("RV_OUTPUT_DIR", "./results")
os.makedirs(output_dir, exist_ok=True)
```

if you already wrote outputs to the snapshot, they're recoverable for up to 7 days. find them at:

```
/scratch/user/rv-workspaces/{project}/{branch}/snapshots/{jobName}-{timestamp}/
```

use `rv sync pull <snapshot-path>/outputs ./local-outputs/` to retrieve them. `rv run -f` (follow mode) prints the snapshot path when the job completes.

### sync behavior

when syncing from a git repo, rv only transfers **git-tracked files** (staged, committed, and untracked non-ignored files via `git ls-files`). this is faster than rsync filtering and ensures only relevant files are synced. if git is not available, rv falls back to `.gitignore` and `.rvignore` filtering.

### non-git projects

projects without a `.git` directory use `_default` as the branch name. snapshots and venvs still work the same way.

### branch name sanitization

branch names are sanitized for filesystem safety: `/` becomes `--`, unsafe characters are stripped, and names are truncated to 80 characters. for example, `feature/my-test` becomes `feature--my-test`. detached HEAD states use `detached-{commitHash}`.

## multi-node logging

multi-node jobs (4+ GPUs across multiple nodes) produce **per-node log files**. each node's stdout and stderr are written to separate files:

```
/scratch/user/.rv/logs/rv-job-12345.node0.out   # node 0 stdout
/scratch/user/.rv/logs/rv-job-12345.node0.err   # node 0 stderr
/scratch/user/.rv/logs/rv-job-12345.node1.out   # node 1 stdout
/scratch/user/.rv/logs/rv-job-12345.node1.err   # node 1 stderr
```

single-node jobs are unchanged — they use a single `.out`/`.err` pair as before.

`rv logs` automatically detects per-node files and shows merged output with `[node0]`, `[node1]` prefixes. use `--node <index>` to filter to a specific node:

```bash
rv logs 12345              # merged view (all nodes)
rv logs 12345 --node 0     # node 0 only
rv logs 12345 --node 1     # node 1 only
rv logs 12345 --err        # stderr from all nodes
```

`rv logs --pull` downloads all per-node files. `rv logs -f` streams per-node output in real time.
